name: vertica-mcp-cicd
on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      action:
        description: apply or destroy
        default: apply
        type: choice
        options: [apply, destroy]

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  VERTICA_IMAGE_URI: ${{ secrets.VERTICA_IMAGE_URI }}
  VERTICA_USER: ${{ secrets.VERTICA_USER }}
  VERTICA_PASSWORD: ${{ secrets.VERTICA_PASSWORD }}
  VERTICA_DATABASE: ${{ secrets.VERTICA_DATABASE }}
  MCP_HTTP_TOKEN: ${{ secrets.MCP_HTTP_TOKEN }}
  ALLOWED_CIDRS: ${{ secrets.ALLOWED_CIDRS }}

jobs:
  preflight:
    runs-on: ubuntu-latest
    steps:
      - name: Check required secrets
        run: |
          req=(AWS_REGION AWS_ACCOUNT_ID ALLOWED_CIDRS VERTICA_IMAGE_URI VERTICA_USER VERTICA_PASSWORD VERTICA_DATABASE MCP_HTTP_TOKEN)
          for k in "${req[@]}"; do
            if [ -z "${!k}" ]; then echo "❌ Missing secret: $k"; exit 1; fi
          done
          echo "✅ Secrets OK"

  lint-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: astral-sh/setup-uv@v3
      - name: Install deps
        run: uv sync --frozen
      - name: Ruff + pytest
        run: |
          uv run python -V
          uv run -m pip install ruff
          uv run ruff check
          uv run pytest -q

  build:
    needs: [preflight, lint-test]
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS (OIDC preferred)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          audience: sts.amazonaws.com
      - name: Login to ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2
      - name: Ensure MCP ECR repo exists
        run: |
          aws ecr describe-repositories --repository-names mcp-vertica >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name mcp-vertica >/dev/null
      - name: Build + push MCP image
        run: |
          REPO=${{ steps.ecr.outputs.registry }}/mcp-vertica
          docker build -f Dockerfile.mcp -t $REPO:latest -t $REPO:${{ github.sha }} .
          docker push $REPO:latest
          docker push $REPO:${{ github.sha }}
      - name: Export repo URL
        run: echo "ECR_MCP_REPO=${{ steps.ecr.outputs.registry }}/mcp-vertica" >> $GITHUB_ENV

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      - name: Backend bootstrap
        working-directory: infra
        run: bash backend-bootstrap.sh
      - name: Terraform init
        working-directory: infra
        run: |
          terraform -version || (curl -s https://releases.hashicorp.com/terraform/1.9.8/terraform_1.9.8_linux_amd64.zip -o tf.zip && sudo unzip -o tf.zip -d /usr/local/bin)
          terraform init -upgrade
      - name: Terraform apply/destroy
        if: ${{ github.event.inputs.action != 'destroy' }}
        working-directory: infra
        env:
          TF_VAR_tf_backend_bucket: ${{ env.TF_BACKEND_BUCKET }}
          TF_VAR_tf_backend_ddb_table: ${{ env.TF_BACKEND_DDB_TABLE }}
        run: |
          terraform apply -auto-approve \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="aws_account_id=${{ env.AWS_ACCOUNT_ID }}" \
            -var="allowed_cidrs=[${{ env.ALLOWED_CIDRS }}]" \
            -var="vertica_image_uri=${{ env.VERTICA_IMAGE_URI }}" \
            -var="mcp_http_token=${{ env.MCP_HTTP_TOKEN }}" \
            -var="vertica_user=${{ env.VERTICA_USER }}" \
            -var="vertica_password=${{ env.VERTICA_PASSWORD }}" \
            -var="vertica_database=${{ env.VERTICA_DATABASE }}" \
            -var="ttl_hours=8"
      - name: Terraform destroy
        if: ${{ github.event.inputs.action == 'destroy' }}
        working-directory: infra
        env:
          TF_VAR_tf_backend_bucket: ${{ env.TF_BACKEND_BUCKET }}
          TF_VAR_tf_backend_ddb_table: ${{ env.TF_BACKEND_DDB_TABLE }}
          TF_VAR_aws_region: ${{ env.AWS_REGION }}
          TF_VAR_aws_account_id: ${{ env.AWS_ACCOUNT_ID }}
        run: terraform destroy -auto-approve
      - name: Capture outputs
        if: ${{ github.event.inputs.action != 'destroy' }}
        id: tfout
        working-directory: infra
        run: |
          echo "ip=$(terraform output -raw public_ip)" >> $GITHUB_OUTPUT
          echo "mcp=$(terraform output -raw mcp_url)" >> $GITHUB_OUTPUT
          echo "vertica=$(terraform output -raw vertica_address)" >> $GITHUB_OUTPUT
      - name: Wait for SSM + smoke test
        if: ${{ github.event.inputs.action != 'destroy' }}
        run: |
          INST_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=vertica-mcp" "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' --output text)
          bash scripts/ssm_smoke.sh "$INST_ID" "${{ env.MCP_HTTP_TOKEN }}"
      - name: Summary
        if: ${{ github.event.inputs.action != 'destroy' }}
        run: |
          echo "MCP URL: ${{ steps.tfout.outputs.mcp }}" >> $GITHUB_STEP_SUMMARY
          echo "Vertica:  ${{ steps.tfout.outputs.vertica }} (db=${{ env.VERTICA_DATABASE }}, user=${{ env.VERTICA_USER }})" >> $GITHUB_STEP_SUMMARY
